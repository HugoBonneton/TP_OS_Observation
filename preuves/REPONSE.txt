-----------------------------------------------------------
A1 — Abstraction : un programme “parle” au noyau
-----------------------------------------------------------

Q1) Citez 3 syscalls vus dans trace_cat_filtre.txt et expliquez leur rôle "fonctionnel".
Voici trois appels système fondamentaux présents dans votre trace :

execve : C'est le tout premier appel. Il permet de charger et exécuter un programme. Dans le tp il demande au noyau de remplacer le processus actuel par l'exécutable /usr/bin/cat

openat : Envoie un syscall our avoir accès à un fichier. Le noyau vérifie les permissions et, si tout est correct, renvoie un entier la dans mon cas 3

read : Il sert à transférer les données du fichier du disque dur à la RAM, par exemple cat l'utilise pour lire le contenu de demo.txt une fois que le fichier est ouvert

Q2) Trouvez un openat(...). Quel est le chemin ouvert ? Avec quel type d’accès (lecture/écriture) ?
Dans votre fichier trace_cat_filtre.txt, vous devriez trouver une ligne ressemblant à celle-ci vers la fin du fichier :

openat(AT_FDCWD, "preuves/demo.txt", O_RDONLY) = 3

Le chemin ouvert : "preuves/demo.txt" / fichier qu'on a créé avec la commande echo

Le type d'accès : O_RDONLY (Open Read-Only) La commande Cat ne fait qu'afficher le contenu sans le modifier, donc uniquement un accès en lecture seule

Q3) Trouvez au moins un code d’erreur (errno) dans trace_ls.txt OU trace_cat.txt. Donnez son nom et interprétez-le.
Même quand une commande réussit, elle génère souvent des erreurs "invisibles" en cherchant des fichiers de configuration qui n'existent pas. Vous trouverez probablement une ligne comme celle-ci :

5517  openat(AT_FDCWD, "preuves/demos.txt", O_RDONLY) = -1 ENOENT (No such file or directory)

Nom de l'erreur : ENOENT

Le syscall openat a échoué car le programme a tenté d'accéder à un fichier qui n'existe pas à l'emplacement indiqué (ici, une erreur de frappe que j'ai fais : demos.txt au lieu de demo.txt). Le noyau renvoie la valeur -1 pour signaler l'échec et définit le code d'erreur ENOENT , ce qui permet au programme de savoir que le chemin ou le fichier est introuvable

-----------------------------------------------------------
A2 — Fichiers, descripteurs (FD) & redirections
-----------------------------------------------------------

Q4) Dans /proc/<pid>/fd, quels numéros de FD correspondent typiquement à stdin/stdout/stderr ?
Les numéros de descripteurs de fichiers (FD) sont des standards sous Linux qui permettent au processus de communiquer avec l'extérieur. Les plus communes sont :

0 : stdin (Entrée) = C'est par ici que le programme reçoit des données, comme le clavier par exemple

1 : stdout (Sortie) = C'est le flux utilisé pour l'affichage normal du texte, exemple l'écran

2 : stderr (Erreur) = C'est le flux réservé aux messages d'erreur, ce flux permet aux erreurs de ne pas se mélanger avec l'entrée et la sortie

Q5) Quelle différence voyez-vous entre fd_list.txt et fd_list_redir.txt ?
La différence se situe au niveau de la destination des liens symboliques pour les FD 1 et 2 :

Dans fd_list.txt : FD 1 et 2 pointent vers un périphérique de type terminal (comme /dev/pts/0). Cela signifie que le texte est "print" directement dans la console

Dans fd_list_redir.txt : Suite à la commande de redirection (> out.txt 2> err.txt), le noyau a modifié ces pointeurs. Le FD 1 pointe désormais vers le fichier preuves/out.txt et le FD 2 vers preuves/err.txt.

Q6) Dans lsof, repérez au moins 1 ligne “REG” (fichier régulier) et 1 ligne “CHR” (périphérique/terminal). Expliquez ce que ça suggère sur l’endroit où va la sortie.
Dans la colonne "TYPE" de la commande lsof, on peut identifier ces deux natures de fichiers :

Ligne CHR (Character device) : Elle correspond généralement au terminal (/dev/pts/...)
Cela suggère que la sortie est traitée comme un flux de caractères envoyé à un périphérique matériel en temps réel (l'écran)

Exemple : 
bash    7958 root   0u   CHR  136,1      0t0      4 /dev/tty1
bash    7958 root   1u   CHR  136,1      0t0      4 /dev/tty1
bash    7958 root   2u   CHR  136,1      0t0      4 /dev/tty1


Ligne REG (Regular file) : Elle correspond aux fichiers créés sur le disque (comme out.txt) 
Cela montre que la sortie est redirigée pour être stockée de façon permanente sur le système

Exemple : 
bash    7958 root txt    REG    7,1  1298416 131316 /usr/bin/bash
bash    7958 root mem    REG    7,1  2003408 132931 /usr/lib/x86_64-linux-gnu/libc.so.6
bash    7958 root mem    REG    7,1   220464 132591 /usr/lib/x86_64-linux-gnu/libtinfo.so.6.5
bash    7958 root mem    REG    7,1   225600 132928 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2

-----------------------------------------------------------
A3 — Mémoire : RSS, VSZ, pages et observation
-----------------------------------------------------------

Q7) Comparez VmSize (VSZ) et VmRSS (RSS). Pourquoi peuvent-ils être très différents ?

Dans mon fichier mem_status.txt, on voit une différence entre ces deux valeurs :

VmSize (Virtual Memory Size) : C'est la taille totale de l'espace d'adressage virtuel que le processus a réservé
Cela inclut tout : code du programme, les zones mémoires allouées mais pas encore utilisées etc ...

VmRSS (Resident Set Size) : C'est la mémoire réellement présente en RAM physique

Pourquoi cette différence ? Le système d'exploitation utilise une technique appelée "Lazy Allocation" ce qui signifis allocation à la demande
Le programme peut demander de réserver 80 Mo , mais le noyau ne lui donnera réellement des pages de RAM physique (VmRSS) que lorsque le programme sera actif

Q8) Dans pmap, repérez une zone “anon” ou “heap”. Que représente-t-elle ?
En regardant le fichier pmap_head.txt, on trouve des lignes marquées [ anon ]

Ce que ça représente : Il s'agit de la mémoire "anonyme"
Cette mémoire anonyme n'est pas sauvegardée dans un fichier spécifique, elle permet de stocker des informations temporaires
Elle ne prend pas de place réel sur le disque

Le Heap est la zone de mémoire vive (RAM) que le programme utilise pour stocker ses données dynamiques
C'est dans cet espace que l'OS a placé les 80 Mo créé en Python et cette mémoire n'existe que dans la RAM pendant que le programme s'exécute

-----------------------------------------------------------
A4 — Ordonnancement : priorité et “nice”
-----------------------------------------------------------

Q9) Que signifie “nice” ? Quel effet attendu quand on augmente le nice (ex: +10) ?

Définition : Le nice est une valeur (de -20 à +19) qui définit la priorité d'un processus pour l'accès au processeur

Effet : Plus on augmente le chiffre (ex: +10), plus le processus devient "nice" et cela signifie qu'il accepte de laisser passer les autres processus avant lui, ce qui fait qu'il devient moins prioritaire

Q10) Qu’observez-vous sur la répartition CPU ?

Avant le "renice", les deux processus se partageaient le CPU 50/50
Après avoir passé le processus B à +10, on observe que le processus A prend une part beaucoup plus importante du CPU

L'ordonnanceur du noyau a pris en compte la nouvelle priorité et a décidé de donner plus de CPU au processus A


-----------------------------------------------------------
A5 — Synthèse
-----------------------------------------------------------

Abstraction (A1/A2) : On a vu qu'une action simple comme afficher du texte, tapper au clavier utilise des syscalls comme write ou encore stdout et stdin
De plus, la redirection montre que linux peut connecter la sortie d'un programme vers un fichier au lieu de l'écran sans changer le programme lui-même grâce à la mémoire tempon 

Décision de l'OS (A4) : L'utilisation du nice a prouvé que c'est le noyau qui décide quel processus a le droit d'utiliser le CPU en priorité grace à sa notation de gentillese 

Mémoire (A3) : J'ai appris que le système économise les ressources en ne donnant de la RAM physique (VmRSS) que lorsque c'est nécessaire, même si le programme a réservé beaucoup de mémoire virtuelle (VmSize)


===========================================================
PARTIE B — BONUS
===========================================================

B1 — Bonus Isolation : namespaces “à la main”
Q11) Pourquoi êtes-vous souvent PID 1 dans ce shell ?


Définition : Un "namespace" de PID crée une nouvelle vue isolée des processus, et chaque processus ne voit que sa tâche
Explication : Comme vous avez créé une nouvelle "bulle" isolée, le premier processus que vous lancez dedans devient automatiquement le PID 1

Q12) Qu’est-ce qui change dans la liste des processus (ps) ? Qu’est-ce qui ne change pas ?

Ce qui change : La commande "ps" ne montre plus les centaines de processus de la VM, mais seulement ceux qui tournent à l'intérieur du namespace 
Ce qui ne change pas : Le noyau reste le même, les ressources de la machine hôte reste les mêmes, ce que l'on obtient c'est une vue "filtrée" de ce qui se passe

B2 — Bonus Ressources : limiter CPU/RAM via systemd
Q13) Où “vit” la limitation (conceptuellement) : processus ? noyau ? groupe de contrôle ?

La limitation ne se trouve pas dans le code du programme, mais elle "vit" dans le groupe de contrôle (cgroup) géré par le noyau
Ce n'est pas le programme qui décide de se limiter lui-même; c'est le noyau ce même noyau utilise l'ordonnanceur et des quotas précis pour surveiller le processus
Dès que le quota de temps est atteint, le noyau intervient par "préemption" pour retirer le processus du processeur


Q14) Comment vérifier que vous êtes dans un cgroup ?


On peut regarder le fichier spécial /proc/self/cgroup.
Ce fichier affiche le chemin du groupe de contrôle auquel appartient le shell actuel dans mon cas : 
0::/system.slice/system-container\x2dgetty.slice/container-getty@1.service

B3 — Bonus Sécurité : capabilities
Q15) Qu’est-ce qu’une capability ? Pourquoi c’est plus fin qu’un binaire setuid root ?


C'est un découpage des privilèges "root" en petites autorisations précises
Au lieu de donner tous les pouvoirs (root) à un programme, on ne lui donne que ce dont il a besoin et cela réduit fortement les risques si le programme est piraté

Q16) À votre avis, quelle permission réseau ping cherche-t-il à obtenir ?

Ping a besoin de la capacité CAP_NET_RAW, ce qui lui permet d'envoyer des paquets ICMP "particuliers" que seul les administrateurs peuvent normalement envoyer

B4 — Bonus Recherche : Thème R3 (Namespaces et conteneurs)

Mini-compte-rendu — Thème R2 : AppArmor / SELinux
La sécurité d'un système Linux repose sur deux modèles de contrôle d'accès : le DAC et le MAC.

DAC vs MAC : La différence fondamentale réside dans l'autorité des permissions
- Le DAC (Discretionary Access Control) correspond aux permissions classiques (UID/GID/RWX) où le propriétaire d'un fichier décide qui peut y accéder
- Le MAC (Mandatory Access Control) est une politique de sécurité imposée par le système (le kernel) que l'utilisateur ne peut pas contourner, même s'il est propriétaire du fichier, uniquement l'administrateur peut choisir



